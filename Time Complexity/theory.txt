1. What is Time Complexity?

Time Complexity measures how the running time of an algorithm grows with input size n.

ğŸ‘‰ It does not measure actual time (seconds), but number of operations relative to n.

2. Why Time Complexity is Important

Compares algorithms independently of hardware

Predicts scalability

Helps choose the most efficient algorithm

3. Asymptotic Analysis

We analyze performance for large n, ignoring constants and lower-order terms.

Three Cases
Case	Meaning
Best Case	Minimum time
Average Case	Expected time
Worst Case	Maximum time (most important for exams)
4. Asymptotic Notations
1ï¸âƒ£ Big-O Notation â€“ Upper Bound

Worst-case time complexity

Example:
If an algorithm takes 3nÂ² + 5n + 10
ğŸ‘‰ O(nÂ²)

2ï¸âƒ£ Big-Î© (Omega) â€“ Lower Bound

Best-case time complexity

Example:
Linear search best case â†’ Î©(1)

3ï¸âƒ£ Big-Î˜ (Theta) â€“ Tight Bound

Exact growth rate

Example:
Binary search â†’ Î˜(log n)

5. Common Time Complexities (Very Important)
Complexity	Name	Example
O(1)	Constant	Access array element
O(log n)	Logarithmic	Binary Search
O(n)	Linear	Linear Search
O(n log n)	Linearithmic	Merge Sort
O(nÂ²)	Quadratic	Bubble Sort
O(nÂ³)	Cubic	Matrix multiplication (naive)
O(2â¿)	Exponential	Recursive Fibonacci
O(n!)	Factorial	Traveling Salesman (brute force)
6. Rules to Calculate Time Complexity
Rule 1: Sequential Statements â†’ Add
O(n) + O(n) = O(n)

Rule 2: Nested Loops â†’ Multiply
for i = 1 to n
  for j = 1 to n


ğŸ‘‰ O(nÂ²)

Rule 3: Drop Constants
O(3n + 10) â†’ O(n)

Rule 4: Drop Lower-Order Terms
O(nÂ² + n) â†’ O(nÂ²)

7. Time Complexity Examples
Linear Search

Best case: O(1)

Worst case: O(n)

Binary Search

Best case: O(1)

Worst & Average: O(log n)

Bubble Sort

Best case (optimized): O(n)

Worst case: O(nÂ²)

8. Time vs Space Complexity
Aspect	Time Complexity	Space Complexity
Measures	Execution time	Memory usage
Concern	Speed	Memory